# SnappyHexMesh

## Creating a geometry

There are a few considerations to make when creating a geometry for meshing with #OpenFOAM/snappyHexMesh ; although both OBJ and STL formats are supported, here we stick with STL only for being a popular format compatible with many CAD tools. Whether you are handling an internal or external flow, consider the following steps:

- Create a STL file from the whole geometry (if exporting from a CAD software, consider exporting all parts to a single STL file). Keep this file for reworking or modifications that might be required later on.

- For fine control of refinement, it is easier to work with separate STL files *per patch*; this is sort of inconvenient but is the way to go for now. So before proceeding *explode* your parent STL file in as many files as patches you need to create. If you modify the parent file, keep in mind you might need to export again the separate patches (at least those that were impacted by the editions).  If for some reason you need to add the patches together (*parent corrupted?*), triangulations in STL format can be simply joined with `cat`:

```bash
cat input-1.stl input-2.stl > merged.stl
```

- #TODO in the above joining idea, one could conceive an automated patch splitting if STL generation software kept right names in different regions!

- Files must be exported in raw text format STL; if you are working with a file *per patch*, this impacts all patch files and the parent file can be kept in binary format. Otherwise (working with a single STL file) the parent file needs to be saved in ASCII format.

 - Edit the patch name in the first/last line of all STL files. The first line must read `solid <patch-name>` and the last `endsolid <patch-name>`. By default STL editing software places a random string there (sometimes related to the file name) or something else. #TODO: check if this is still a requirement, some of the tutorials we have do not respect this.

- In the the `OpenFOAM` case, save generated files to `constant/geometry/`; if the case will have many variants, the recommended practice is to keep the parent and exported files in the reference setup case and clone the generated mesh to the variant cases (except in case of mesh resolution studies, when you might need the STL files back again for reworking the mesh).

- Keep note of the unit system used for STL conception. By default `OpenFOAM` will require SI units, so stick to meters and preferably convert units before exporting the STL file/patches if possible. Otherwise one can carry unit transformations with #OpenFOAM/surfaceTransformPoints. Convert a triangulation from millimeters to meters as follows:

```bash
surfaceTransformPoints           \
    -scale '(0.001 0.001 0.001)' \
    <input.stl>                  \
    <output.stl>
```
## Adding geometry to mesh

The STL files that you can add to the mesh are found under `constant/geometry/` as discussed in the previous section. To add one of these files for meshing one needs to create an entry under `geometry` sub-dictionary of type `triSurfaceMesh`. A minimal example would be for adding file `cylinder.stl` referring to patch name `cylinder` is:

```C
geometry
{
	// This is how it will be called in OpenFOAM.
	cylinder
    {
	    // Type specification for STL files.
        type triSurfaceMesh;

		// Just the name of the STL file.
        file "cylinder.stl";
    }
}
```

#OpenFOAM/snappyHexMesh/refinementSurfaces #OpenFOAM/blockMesh #OpenFOAM/snappyHexMesh/castellatedMeshControls 

Notice that this is probably not enough for *really* detecting the surface in `snappyHexMesh` because in the absence of an entry under `refinementSurfaces` it will be meshing the inside and outside of the geometry, what most probably is not what you are looking for. Furthermore, you will be starting from a background mesh generated by `blockMesh` which might be coarse. If the features of the added geometry are much smaller than the background mesh, it will simply produce an almost random-looking grid inside the background mesh. This is why you *mandatorily* need to add an entry to sub-dictionary `refinementSurfaces` under `castellatedMeshControls` so that the surface is properly resolved. For the present case that is:

```C
refinementSurfaces
{
	// Patch name as defined under `geometry`.
	cylinder
	{
		// Global and curvature refinement levels
		// (according to `resolveFeatureAngle`).
		level (2  4);
	}
}
```
